var c = Object.defineProperty; var i = (G, Q) => { for (var X in Q) c(G, X, { get: Q[X], enumerable: !0, configurable: !0, set: (Y) => Q[X] = () => Y }) }; var o = {}; i(o, { slotTypes: () => _, permissions: () => n, itemsHandlingFlags: () => N, itemClassifications: () => R, clientStatuses: () => W }); var W = { disconnected: 0, connected: 5, ready: 10, playing: 20, goal: 30 }, R = { progression: 1, useful: 2, trap: 4, normal: 0 }, N = { minimal: 0, others: 1, own: 2, starting: 4, all: 7 }, n = { disabled: 0, enabled: 1, goal: 2, auto: 6, autoEnabled: 7 }, _ = { spectator: 0, player: 1, group: 2 }; class x extends Error { } class D extends Error { argumentName; value; constructor(G, Q, X) { super(G); this.argumentName = Q, this.value = structuredClone(X) } } class T extends Error { errors = []; constructor(G, Q) { super(G); this.errors = Q } } class K extends Error { } var C = { timeout: 1e4, autoFetchDataPackage: !0, maximumMessages: 1000, debugLogVersions: !0 }; var r = { major: 0, minor: 5, build: 1 }, l = "2.0.2"; function F() { const G = []; for (let Q = 0; Q < 36; Q++)G.push(Math.floor(Math.random() * 16)); return G[14] = 4, G[19] = G[19] &= -5, G[19] = G[19] |= 8, G[8] = G[13] = G[18] = G[23] = "-", G.map((Q) => Q.toString(16)).join("") } var H = { password: "", uuid: F(), tags: [], version: r, items: N.all, slotData: !0 }; class z { #G; #Q; #X; #Y; constructor(G, Q, X, Y) { this.#G = G, this.#Q = Q, this.#X = X, this.#Y = Y } toString() { return this.name } get receiver() { return this.#Y } get sender() { return this.#X } get name() { return this.#G.package.lookupItemName(this.game, this.#Q.item, !0) } get id() { return this.#Q.item } get locationName() { return this.#G.package.lookupLocationName(this.sender.game, this.#Q.location, !0) } get locationId() { return this.#Q.location } get locationGame() { return this.sender.game } get game() { return this.receiver.game } get progression() { return (this.flags & R.progression) === R.progression } get useful() { return (this.flags & R.useful) === R.useful } get trap() { return (this.flags & R.trap) === R.trap } get filler() { return this.flags === R.normal } get flags() { return this.#Q.flags } } class O { game; checksum; itemTable; locationTable; reverseItemTable; reverseLocationTable; constructor(G, Q) { this.game = G, this.checksum = Q.checksum, this.itemTable = Object.freeze(Q.item_name_to_id), this.locationTable = Object.freeze(Q.location_name_to_id), this.reverseItemTable = Object.freeze(Object.fromEntries(Object.entries(this.itemTable).map(([X, Y]) => [Y, X]))), this.reverseLocationTable = Object.freeze(Object.fromEntries(Object.entries(this.locationTable).map(([X, Y]) => [Y, X]))) } exportPackage() { return { checksum: this.checksum, item_name_to_id: { ...this.itemTable }, location_name_to_id: { ...this.locationTable } } } } class I { #G; #Q = new Map; #X = new Map; #Y = new Set; constructor(G) { this.#G = G, this.#G.socket.on("roomInfo", (Q) => { this.#Q.clear(), this.#X.clear(), this.#Y.clear(), this.#Q.set("Archipelago", this.#Z()); for (let X in Q.datapackage_checksums) this.#X.set(X, Q.datapackage_checksums[X]), this.#Y.add(X) }) } findPackage(G) { return this.#Q.get(G) ?? null } async fetchPackage(G = [], Q = !0) { if (G.length === 0) G = Array.from(this.#Y); G = G.filter((Y) => { if (!this.#Y.has(Y)) return !1; if (this.#Q.get(Y)?.checksum !== this.#X.get(Y)) return !0; return !1 }); const X = { games: {} }; for (let Y of G) { const Z = { cmd: "GetDataPackage", games: [Y] }, [$] = await this.#G.socket.send(Z).wait("dataPackage"); X.games[Y] = $.data.games[Y] } if (Q) this.importPackage(X); return X } importPackage(G) { for (let Q in G.games) this.#Q.set(Q, new O(Q, G.games[Q])), this.#X.set(Q, G.games[Q].checksum) } exportPackage() { return { games: this.#Q.entries().reduce((G, [Q, X]) => { return G[Q] = X.exportPackage(), G }, {}) } } lookupItemName(G, Q, X = !0) { const Y = `Unknown Item ${Q}`, Z = this.findPackage(G); if (!Z) return X ? Y : void 0; const $ = Z.reverseItemTable[Q]; if (X && $ === void 0) return Y; return $ } lookupLocationName(G, Q, X = !0) { const Y = `Unknown Location ${Q}`, Z = this.findPackage(G); if (!Z) return X ? Y : void 0; const $ = Z.reverseLocationTable[Q]; if (X && $ === void 0) return Y; return $ } #Z() { return new O("Archipelago", { checksum: "ac9141e9ad0318df2fa27da5f20c50a842afeecb", item_name_to_id: { Nothing: -1 }, location_name_to_id: { "Cheat Console": -1, Server: -2 } }) } } class S { #G; #Q = []; #X; #Y; constructor(G, Q, X) { this.#G = G, this.#X = Q, this.#Y = X } replace(G) { return this.#Q.push({ operation: "replace", value: G }), this } default() { return this.#Q.push({ operation: "default", value: null }), this } add(G) { return this.#Q.push({ operation: "add", value: G }), this } multiply(G) { return this.#Q.push({ operation: "mul", value: G }), this } power(G) { return this.#Q.push({ operation: "pow", value: G }), this } remainder(G) { return this.#Q.push({ operation: "mod", value: G }), this } floor() { return this.#Q.push({ operation: "floor", value: null }), this } ceiling() { return this.#Q.push({ operation: "ceil", value: null }), this } max(G) { return this.#Q.push({ operation: "max", value: G }), this } min(G) { return this.#Q.push({ operation: "min", value: G }), this } and(G) { return this.#Q.push({ operation: "and", value: G }), this } or(G) { return this.#Q.push({ operation: "or", value: G }), this } xor(G) { return this.#Q.push({ operation: "xor", value: G }), this } leftShift(G) { return this.#Q.push({ operation: "left_shift", value: G }), this } rightShift(G) { return this.#Q.push({ operation: "right_shift", value: G }), this } remove(G) { return this.#Q.push({ operation: "remove", value: G }), this } pop(G) { return this.#Q.push({ operation: "pop", value: G }), this } update(G) { return this.#Q.push({ operation: "update", value: G }), this } async commit(G = !1) { const Q = F(), X = { cmd: "Set", default: this.#Y, key: this.#X, operations: this.#Q, want_reply: G, uuid: Q }; if (this.#G.socket.send(X), !G) return; const [Y] = await this.#G.socket.wait("setReply", (Z) => Z.uuid === Q); return Y.value } } class A { #G; #Q = {}; #X = {}; constructor(G) { this.#G = G, this.#G.socket.on("disconnected", () => { this.#Q = {}, this.#X = {} }).on("setReply", (Q) => { this.#Q[Q.key] = Q.value; const X = this.#X[Q.key]; if (X) X.forEach((Y) => Y(Q.key, Q.value, Q.original_value)) }).on("connected", () => { if (this.#G.options.debugLogVersions) { const Q = `${this.#G.game}:${l}:${navigator?.userAgent}`; this.prepare("archipelago.js__runtimes", {}).default().update({ [Q]: !0 }).commit(!1) } }) } get store() { return structuredClone(this.#Q) } async fetch(G, Q = !1) { let X = typeof G === "string" ? [G] : G; if (Q) { const Z = X.filter(($) => this.#Q[$] === void 0); if (Z.length > 0) this.#G.socket.send({ cmd: "SetNotify", keys: Z }) } let Y = {}; if (X = X.filter((Z) => { const $ = structuredClone(this.#Q[Z]), j = $ !== void 0; if (j) Y[Z] = $; return !j }), X.length > 0) { const Z = await this.#Y(X); Y = { ...Y, ...Z } } if (Q) this.#Q = { ...this.#Q, ...Y }; return typeof G === "string" ? Y[G] : Y } async notify(G, Q) { return G.forEach((X) => { this.#X[X] ??= [], this.#X[X].push(Q) }), this.fetch(G, !0) } prepare(G, Q) { if (G.startsWith("_read_")) throw TypeError("Cannot manipulate read only keys."); return new S(this.#G, G, Q) } async fetchItemNameGroups(G) { return await this.fetch([`_read_item_name_groups_${G}`], !0) } async fetchLocationNameGroups(G) { return await this.fetch([`_read_location_name_groups_${G}`], !0) } async#Y(G) { const Q = F(), [X] = await this.#G.socket.send({ cmd: "Get", keys: G, uuid: Q }).wait("retrieved", (Y) => Y.uuid === Q); return X.keys } } class E { #G = {}; addEventListener(G, Q, X = !1) { this.#G[G] ??= [], this.#G[G].push([Q, X]) } removeEventListener(G, Q) { const X = this.#G[G]; if (X && X.length > 0) this.#G[G] = X.filter(([Y]) => Y !== Q) } dispatchEvent(G, Q) { const X = this.#G[G] ?? []; for (let [Y, Z] of X) if (Y(...Q), Z) this.removeEventListener(G, Y) } } class J { #G = new E; on(G, Q) { return this.#G.addEventListener(G, Q), this } off(G, Q) { return this.#G.removeEventListener(G, Q), this } async wait(G, Q = () => !0) { return new Promise((X) => { const Y = (...Z) => { if (Q(...Z)) this.#G.removeEventListener(G, Y), X(Z) }; this.#G.addEventListener(G, Y) }) } emit(G, Q) { this.#G.dispatchEvent(G, Q) } } class M extends J { #G; #Q = Number.MIN_SAFE_INTEGER; constructor(G) { super(); this.#G = G, this.#G.socket.on("bounced", (Q) => { if (Q.tags?.includes("DeathLink") && Q.data.time && Q.data.source) { const X = Q.data; if (X.time === this.#Q) return; this.#Q = X.time, this.emit("deathReceived", [X.source, X.time * 1000, X.cause]) } }) } get enabled() { return this.#G.arguments.tags.includes("DeathLink") } enableDeathLink() { if (this.#G.arguments.tags.includes("DeathLink")) return; this.#G.updateTags([...this.#G.arguments.tags, "DeathLink"]) } disableDeathLink() { if (!this.#G.arguments.tags.includes("DeathLink")) return; this.#G.updateTags(this.#G.arguments.tags.filter((G) => G !== "DeathLink")) } sendDeathLink(G, Q) { if (!this.#G.authenticated) throw new K("Cannot send death links before connecting and authenticating."); if (!this.enabled) return; this.#Q = Math.ceil(Date.now() / 1000); const X = { source: G, cause: Q, time: this.#Q }; this.#G.bounce({ tags: ["DeathLink"] }, X) } } class V { #G; #Q; #X; constructor(G, Q) { this.#G = G, this.#Q = Q, this.#X = new z(this.#G, { item: Q.item, location: Q.location, player: Q.finding_player, flags: Q.item_flags }, this.#G.players.findPlayer(Q.finding_player), this.#G.players.findPlayer(Q.receiving_player)) } get item() { return this.#X } get found() { return this.#Q.found } get entrance() { return this.#Q.entrance || "Vanilla" } } class f extends J { #G; #Q = []; #X = []; constructor(G) { super(); this.#G = G, this.#G.socket.on("receivedItems", (Q) => { let X = Q.index; const Y = Q.items.length, Z = [...Q.items]; while (Z.length > 0) { const $ = Z.shift(); this.#Q[X++] = new z(this.#G, $, this.#G.players.findPlayer($.player), this.#G.players.self) } this.emit("itemsReceived", [this.#Q.slice(Q.index, Q.index + Y), Q.index]) }).on("connected", () => { this.#X = [], this.#Q = [], this.#G.storage.notify([`_read_hints_${this.#G.players.self.team}_${this.#G.players.self.slot}`], this.#Y.bind(this)).then((Q) => { const X = Q[`_read_hints_${this.#G.players.self.team}_${this.#G.players.self.slot}`]; this.#X = X.map((Y) => new V(this.#G, Y)), this.emit("hintsInitialized", [this.#X]) }).catch((Q) => { throw Q }) }) } get received() { return [...this.#Q] } get hints() { return [...this.#X] } get count() { return this.#Q.length } #Y(G, Q) { for (let X = 0; X < Q.length; X++)if (this.#X[X] === void 0) this.#X[X] = new V(this.#G, Q[X]), this.emit("hintReceived", [this.#X[X]]); else if (this.#X[X].found !== Q[X].found) this.#X[X] = new V(this.#G, Q[X]), this.emit("hintFound", [this.#X[X]]) } } class P { client; part; constructor(G, Q) { this.client = G, this.part = Q } toString() { return this.text } } class w extends P { part; type = "item"; item; constructor(G, Q, X, Y) { super(G, Q); const Z = G.players.findPlayer(Q.player, Y.team); this.part = Q, this.item = new z(G, X, Z, Y) } get text() { return this.item.name } } class b extends P { #G; part; type = "location"; id; constructor(G, Q) { super(G, Q); const X = G.players.findPlayer(Q.player), Y = G.package.findPackage(X.game); if (this.part = Q, Q.type === "location_name") this.#G = Q.text, this.id = Y.locationTable[Q.text]; else this.id = parseInt(Q.text), this.#G = G.package.lookupLocationName(X.game, this.id, !0) } get text() { return this.#G } } class v extends P { part; type = "color"; color; constructor(G, Q) { super(G, Q); this.part = Q, this.color = Q.color } get text() { return this.part.text } } class y extends P { part; type; constructor(G, Q) { super(G, Q); if (this.part = Q, this.part.type === "entrance_name") this.type = "entrance"; else this.type = "text" } get text() { return this.part.text } } class m extends P { part; type = "player"; player; constructor(G, Q) { super(G, Q); if (this.part = Q, Q.type === "player_id") this.player = G.players.findPlayer(parseInt(Q.text)); else { const X = G.players.teams[G.players.self.team].find((Y) => Y.name === Q.text); if (!X) throw new Error(`Cannot find player under name: ${Q.text}`); this.player = X } } get text() { return this.player.alias } } class u extends J { #G; #Q = []; get log() { return [...this.#Q] } constructor(G) { super(); this.#G = G, this.#G.socket.on("printJSON", this.#X.bind(this)) } async say(G) { if (!this.#G.authenticated) throw new K("Cannot send chat messages without being authenticated."); G = G.trim(); const Q = { cmd: "Say", text: G }; this.#G.socket.send(Q), await this.wait("chat", (X) => X === G) } #X(G) { const Q = []; for (let Y of G.data) switch (Y.type) { case "item_id": case "item_name": { const Z = G; let $; if (Z.type === "ItemCheat") $ = this.#G.players.findPlayer(Z.receiving, Z.team); else $ = this.#G.players.findPlayer(Z.receiving); Q.push(new w(this.#G, Y, Z.item, $)); break } case "location_id": case "location_name": { Q.push(new b(this.#G, Y)); break } case "color": { Q.push(new v(this.#G, Y)); break } case "player_id": case "player_name": { Q.push(new m(this.#G, Y)); break } default: { Q.push(new y(this.#G, Y)); break } }const X = Q.map((Y) => Y.text).join(""); if (this.#G.options.maximumMessages >= 1) this.log.push({ text: X, nodes: Q }), this.log.splice(0, this.log.length - this.#G.options.maximumMessages); switch (G.type) { case "ItemSend": { const Y = this.#G.players.findPlayer(G.item.player), Z = this.#G.players.findPlayer(G.receiving), $ = new z(this.#G, G.item, Y, Z); this.emit("itemSent", [X, $, Q]); break } case "ItemCheat": { const Y = this.#G.players.findPlayer(G.item.player, G.team), Z = this.#G.players.findPlayer(G.receiving, G.team), $ = new z(this.#G, G.item, Y, Z); this.emit("itemCheated", [X, $, Q]); break } case "Hint": { const Y = this.#G.players.findPlayer(G.item.player), Z = this.#G.players.findPlayer(G.receiving), $ = new z(this.#G, G.item, Y, Z); this.emit("itemHinted", [X, $, G.found, Q]); break } case "Join": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("connected", [X, Y, G.tags, Q]); break } case "Part": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("disconnected", [X, Y, Q]); break } case "Chat": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("chat", [G.message, Y, Q]); break } case "ServerChat": { this.emit("serverChat", [G.message, Q]); break } case "TagsChanged": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("tagsUpdated", [X, Y, G.tags, Q]); break } case "Tutorial": { this.emit("tutorial", [X, Q]); break } case "CommandResult": { this.emit("userCommand", [X, Q]); break } case "AdminCommandResult": { this.emit("adminCommand", [X, Q]); break } case "Goal": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("goaled", [X, Y, Q]); break } case "Release": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("released", [X, Y, Q]); break } case "Collect": { const Y = this.#G.players.findPlayer(G.slot, G.team); this.emit("collected", [X, Y, Q]); break } case "Countdown": this.emit("countdown", [X, G.countdown, Q]) }this.emit("message", [X, Q]) } } class q { #G; #Q; constructor(G, Q) { this.#G = G, this.#Q = Q } toString() { return this.alias } get name() { return this.#Q.name } get alias() { return this.#Q.alias } get game() { if (this.slot === 0) return "Archipelago"; return this.#X.game } get type() { if (this.slot === 0) return _.spectator; return this.#X.type } get team() { return this.#Q.team } get slot() { return this.#Q.slot } get members() { if (this.type !== _.group) return []; return this.#G.players.teams[this.team].filter((G) => this.#X.group_members.includes(G.slot)) } get groups() { if (this.slot === 0) return []; return this.#G.players.teams[this.team].filter((G) => G.slot !== 0 && this.#G.players.slots[G.slot].group_members.includes(this.slot)) } async fetchStatus() { if (this.type === _.group) return W.goal; return await this.#G.storage.fetch(`_read_client_status_${this.team}_${this.slot}`) ?? 0 } async fetchSlotData() { return await this.#G.storage.fetch(`_read_slot_data_${this.slot}`) } async fetchHints() { return (await this.#G.storage.fetch(`_read_hints_${this.team}_${this.slot}`)).map((Q) => new V(this.#G, Q)) } get #X() { return this.#G.players.slots[this.slot] } } class g extends J { #G; #Q = []; #X = {}; #Y = 0; #Z = 0; constructor(G) { super(); this.#G = G, this.#G.socket.on("connected", (Q) => { this.#X = Object.freeze(Q.slot_info), this.#Q = [], this.#Y = Q.slot, this.#Z = Q.team; for (let X of Q.players) this.#Q[X.team] ??= [{ team: X.team, slot: 0, name: "Archipelago", alias: "Archipelago" }], this.#Q[X.team][X.slot] = X }).on("roomUpdate", (Q) => { if (!Q.players) return; for (let X of Q.players) if (this.#Q[X.team][X.slot].alias !== X.alias) { const Y = this.#Q[X.team][X.slot].alias; this.#Q[X.team][X.slot] = X, this.emit("aliasUpdated", [new q(this.#G, X), Y, X.alias]) } }) } get self() { if (this.#Y === 0) throw new Error("Cannot lookup own player object when client has never connected to a server."); return new q(this.#G, this.#Q[this.#Z][this.#Y]) } get slots() { return this.#X } get teams() { const G = []; for (let Q = 0; Q < this.#Q.length; Q++) { G[Q] = []; for (let X = 0; X < this.#Q[Q].length; X++)G[Q].push(new q(this.#G, this.#Q[Q][X])) } return G } findPlayer(G, Q) { if (Q === void 0) Q = this.#G.players.self.team; if (this.#Q[Q]) return new q(this.#G, this.#Q[Q][G]); return } } class h extends J { #G; #Q = { major: -1, minor: -1, build: -1 }; #X = { major: -1, minor: -1, build: -1 }; #Y = []; #Z = []; #V = ""; #x = !1; #z = 0; #U = 0; #J = 0; #K = { release: 0, collect: 0, remaining: 0 }; #R = []; #$ = []; #F = !1; get serverVersion() { return { ...this.#Q } } get generatorVersion() { return { ...this.#X } } get games() { return [...this.#Y] } get tags() { return [...this.#Z] } get seedName() { return this.#V } get password() { return this.#x } get permissions() { return { ...this.#K } } get hintPoints() { return this.#z } get hintCost() { if (this.hintCostPercentage > 0) return Math.max(1, Math.floor(this.hintCostPercentage * this.allLocations.length * 0.01)); return 0 } get hintCostPercentage() { return this.#U } get locationCheckPoints() { return this.#J } get missingLocations() { return [...this.#R].sort() } get checkedLocations() { return [...this.#$].sort() } get allLocations() { return [...this.#R, ...this.#$].sort() } get race() { return this.#F } constructor(G) { super(); this.#G = G, this.#G.socket.on("roomInfo", (Q) => { this.#Q = { major: Q.version.major, minor: Q.version.minor, build: Q.version.build }, this.#X = { major: Q.generator_version.major, minor: Q.generator_version.minor, build: Q.generator_version.build }, this.#Z = Q.tags, this.#Y = Q.games, this.#V = Q.seed_name, this.#x = Q.password, this.#K = Q.permissions, this.#U = Q.hint_cost, this.#J = Q.location_check_points }).on("connected", (Q) => { this.#R = Q.missing_locations, this.#$ = Q.checked_locations, this.emit("locationsChecked", [this.checkedLocations]), this.#z = Q.hint_points, this.emit("hintPointsUpdated", [0, Q.hint_points]) }).on("roomUpdate", (Q) => { if (Q.hint_cost !== void 0) { const [X, Y] = [this.hintCost, this.hintCostPercentage]; this.#U = Q.hint_cost, this.emit("hintCostUpdated", [X, this.hintCost, Y, this.hintCostPercentage]) } if (Q.hint_points !== void 0) { const X = this.#z; this.#z = Q.hint_points, this.emit("hintPointsUpdated", [X, this.hintPoints]) } if (Q.location_check_points !== void 0) { const X = this.#J; this.#J = Q.location_check_points, this.emit("locationCheckPointsUpdated", [X, this.locationCheckPoints]) } if (Q.password !== void 0) this.#x = Q.password, this.emit("passwordUpdated", [this.password]); if (Q.permissions !== void 0) { const X = this.#K; this.#K = Q.permissions, this.emit("permissionsUpdated", [X, this.permissions]) } if (Q.checked_locations !== void 0) this.#$ = [...this.#$, ...Q.checked_locations], this.#R = this.missingLocations.filter((X) => !Q.checked_locations?.includes(X)), this.emit("locationsChecked", [Q.checked_locations]) }) } } class d extends J { #G = null; #Q = !1; constructor() { super() } get connected() { return this.#Q } get url() { return this.#G?.url ?? "" } send(...G) { if (this.#G) return this.#G.send(JSON.stringify(G)), this.emit("sentPackets", [G]), this; throw new x("Unable to send packets to the server; not connected to a server.") } async connect(G) { if (this.disconnect(), typeof G === "string") { if (!/^([a-zA-Z]+:)\/\/[A-Za-z0-9_.~\-:]+/i.test(G)) try { return await this.connect(new URL(`wss://${G}`)) } catch { return await this.connect(new URL(`ws://${G}`)) } G = new URL(G) } if (G.port = G.port || "38281", G.protocol !== "wss:" && G.protocol !== "ws:") throw new TypeError("Unexpected protocol. Archipelago only supports the ws:// and wss:// protocols."); try { return new Promise((Q, X) => { const Y = this.#Y(); if (Y === null) throw new x("Unable to find a suitable WebSocket API in the current runtime."); this.#G = new Y(G), this.#G.onmessage = this.#X.bind(this), this.#G.onclose = () => { this.disconnect(), X(new x("Failed to connect to Archipelago server.")) }, this.#G.onerror = () => { this.disconnect(), X(new x("Failed to connect to Archipelago server.")) }, this.#G.onopen = () => { this.wait("roomInfo").then(([Z]) => { if (this.#Q = !0, this.#G) { this.#G.onclose = this.disconnect.bind(this), this.#G.onerror = this.disconnect.bind(this), Q(Z); return } this.disconnect(), X(new x("Failed to connect to Archipelago server.")) }).catch((Z) => { throw Z }) } }) } catch (Q) { throw this.disconnect(), Q } } disconnect() { if (!this.connected) return; this.#Q = !1, this.#G?.close(), this.#G = null, this.emit("disconnected", []) } #X(G) { const Q = JSON.parse(G.data); for (let X of Q) { switch (X.cmd) { case "ConnectionRefused": this.emit("connectionRefused", [X]); break; case "Bounced": this.emit("bounced", [X, X.data]); break; case "Connected": this.emit("connected", [X]); break; case "DataPackage": this.emit("dataPackage", [X]); break; case "InvalidPacket": this.emit("invalidPacket", [X]); break; case "LocationInfo": this.emit("locationInfo", [X]); break; case "PrintJSON": this.emit("printJSON", [X]); break; case "ReceivedItems": this.emit("receivedItems", [X]); break; case "Retrieved": this.emit("retrieved", [X]); break; case "RoomInfo": this.emit("roomInfo", [X]); break; case "RoomUpdate": this.emit("roomUpdate", [X]); break; case "SetReply": this.emit("setReply", [X]); break }this.emit("receivedPacket", [X]) } } #Y() { let G = null; if (typeof window !== "undefined") G = window.WebSocket || window.MozWebSocket; else if (typeof global !== "undefined") G = global.WebSocket || global.MozWebSocket; else if (typeof self !== "undefined") G = self.WebSocket || self.MozWebSocket; else if (typeof WebSocket !== "undefined") G = WebSocket; else if (typeof MozWebSocket !== "undefined") G = MozWebSocket; return G } } class s { #G = !1; #Q = H; #X = ""; #Y = ""; socket = new d; package = new I(this); storage = new A(this); room = new h(this); players = new g(this); items = new f(this); messages = new u(this); deathLink = new M(this); options; get authenticated() { return this.socket.connected && this.#G } get name() { return this.#X } get game() { return this.#Y } get arguments() { return { ...this.#Q } } constructor(G) { if (G) this.options = { ...C, ...G }; else this.options = { ...C }; this.socket.on("disconnected", () => { this.#G = !1 }).on("sentPackets", (Q) => { for (let X of Q) if (X.cmd === "ConnectUpdate") this.#Q.tags = X.tags, this.#Q.items = X.items_handling }) } async login(G, Q, X = "", Y) { if (Q === "") throw new D("Provided slot name cannot be blank.", "name", Q); if (Y) this.#Q = { ...H, ...Y }; else this.#Q = { ...H }; const Z = new Set(this.arguments.tags); if (!X && !Z.has("HintGame") && !Z.has("Tracker") && !Z.has("TextOnly")) Z.add("TextOnly"); this.#Q.tags = Array.from(Z); const $ = { cmd: "Connect", name: Q, game: X, password: this.arguments.password, slot_data: this.arguments.slotData, items_handling: this.arguments.items, uuid: this.arguments.uuid, tags: this.arguments.tags, version: { ...this.arguments.version, class: "Version" } }; if (await this.socket.connect(G), this.options.autoFetchDataPackage) await this.package.fetchPackage(); return new Promise((j, k) => { const p = setTimeout(() => k(new x("Server failed to respond in time.")), this.options.timeout), B = (U) => { this.#G = !0, this.#Y = U.slot_info[U.slot].game, this.#X = U.slot_info[U.slot].name, this.socket.off("connected", B).off("connectionRefused", L), clearTimeout(p), j(U.slot_data) }, L = (U) => { this.socket.off("connected", B).off("connectionRefused", L), clearTimeout(p), k(new T(`Connection was refused by the server. Reason(s): [${U.errors?.join(", ")}`, U.errors ?? [])) }; this.socket.on("connected", B.bind(this)).on("connectionRefused", L.bind(this)).send($) }) } updateStatus(G) { if (!this.authenticated) throw new K("Cannot update status while not connected and authenticated."); this.socket.send({ cmd: "StatusUpdate", status: G }) } goal() { this.updateStatus(W.goal) } updateTags(G) { if (!this.authenticated) throw new K("Cannot update tags while not connected and authenticated."); this.socket.send({ cmd: "ConnectUpdate", tags: G, items_handling: this.arguments.items }) } updateItemsHandling(G) { if (!this.authenticated) throw new K("Cannot update tags while not connected and authenticated."); this.socket.send({ cmd: "ConnectUpdate", tags: this.arguments.tags, items_handling: G }) } check(...G) { if (!this.authenticated) throw new K("Cannot check locations while not connected and authenticated."); G = G.filter((Q) => this.room.missingLocations.includes(Q)), this.socket.send({ cmd: "LocationChecks", locations: G }) } async scout(G, Q = 0) { if (!this.authenticated) throw new K("Cannot scout locations while not connected and authenticated."); G = G.filter((Y) => this.room.allLocations.includes(Y)); const [X] = await this.socket.send({ cmd: "LocationScouts", create_as_hint: Q, locations: G }).wait("locationInfo", (Y) => { return Y.locations.map((Z) => Z.location).toSorted().join(",") === G.toSorted().join(",") }); return X.locations.map((Y) => new z(this, Y, this.players.self, this.players.findPlayer(Y.player))) } bounce(G, Q) { if (!this.authenticated) throw new K("Cannot send bounces while not connected and authenticated."); this.socket.send({ cmd: "Bounce", data: Q, games: G.games ?? [], slots: G.slots ?? [], tags: G.tags ?? [] }) } } export { o as API, P as BaseMessageNode, s as Client, v as ColorMessageNode, I as DataPackageManager, A as DataStorageManager, M as DeathLinkManager, C as defaultClientOptions, H as defaultConnectionOptions, J as EventBasedManager, V as Hint, S as IntermediateDataOperation, z as Item, w as ItemMessageNode, f as ItemsManager, l as libraryVersion, b as LocationMessageNode, u as MessageManager, O as PackageMetadata, q as Player, m as PlayerMessageNode, g as PlayersManager, h as RoomStateManager, d as SocketManager, r as targetVersion, y as TextualMessageNode };

